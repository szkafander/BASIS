%% graph construction .add_node workflow tutorial
% hit ctrl+enter while highlighting a cell to run it.
% comments explain the code.

%% the following demonstrates Graph construction using the add_node method.
% here we recreate the Graph in the file
% 'data/graphs/pyrometry_bicolor_image_registration.gml'. you may open the
% graph in an editor and follow along step by step. the .gml also contains
% explanation for each Node.

% the .add_node method is useful for adding Nodes one-by-one and plotting
% the resulting Graph object at every step. this method is more natural to
% use in the command line than the cell of Nodes method.

% the Graph we will build here actually performs image registration. this 
% is a good tutorial to start if you just want to see how to put together a
% simple workflow. to do this with the cell of Nodes method, see 
% tutorials.graph_construction_cell_of_nodes

tic;

graph_ = Graph();

% input-output routing is set in the order of adding the Nodes. take extra
% care when setting routing for Nodes where the order of inputs matter (see
% below).
graph_.add_node(Node( ...
    'label', 'frame_1', ...
    'pipeline', @data.read_image, ...
    'group', 1, ...
    'outputnodes', 'merge'));
graph_.add_node(Node( ...
    'label', 'frame_2', ...
    'pipeline', @data.read_image, ...
    'group', 2));
graph_.add_node(Node( ...
    'label', 'transformation_matrix', ...
    'pipeline', ...
    @(~)data.load_parameter( ...
    [get_basis_path '..\data\other\transformation_matrix.mat']), ...
    'group', 2));
% it is a good idea to set inputnodes explicity for nodes that have
% multiple inputs and the order of the inputs matters. for nodes like this,
% only set their inputnodes in the appropriate order.
% we add a Node that we can play with later. the variable that holds the
% original object is called show_node.
show_node = Node( ...
    'label', 'show', ...
    'pipeline', ...
    @(image_1, image_2)imshowpair(image_1, image_2, ...
    'scaling', 'independent', 'colorchannels', [2 1 1]), ...
    'inputnodes', {'frame_1', 'register_2'});
graph_.add_node(show_node.deep_copy());
% we will add a deep copy of this object to the graph to avoid destroying 
% the Node with .remove_node() later. generally, using the .deep_copy()
% method is advised when passing Node objects as workspace variables.
graph_.add_node(Node( ...
    'label', 'register', ...
    'pipeline', ...
    @(image, ...
    transformation_matrix)preprocessing.transform_image ...
    (image, transformation_matrix), ...
    'inputnodes', {'frame_2', 'transformation_matrix'}, ...
    'outputnodes', 'show'));

disp('graph created.');
toc;

% plot graph
graph_.plot();

% graph summary
% note: you don't have to explicitly set all input-output routing. Graph
% will figure out all connections from incomplete edge data. but again, pay
% special attention to Nodes that receive multiple inputs in a certain
% order.
graph_.print_summary();

%% you can remove nodes using the remove_node method
% let us remove the 'show' node and see what happens. remove_node takes a
% numeric value (scalar or vector), a label string or a cell string of
% labels. here we specify the label of the node we wish to remove.
graph_.remove_node('show');
graph_.plot();
graph_.print_summary();

%% we add the merge node back
% notice that connections are re-scanned and thus preserved
graph_.add_node(show_node);
graph_.plot();
graph_.print_summary();

%% toggling Graph updating
% notice that using the .add_node() workflow was quite slow. this is
% because by default, Graph objects update themselves on every call of
% .add_node() in order to provide feedback, warnings and error messages
% during constructing the graph in this step-by-step manner. however,
% updating can be turned on and off using the .toggle_updating() method.
% here we recreate the graph without auto-updating.

tic;

graph_ = Graph();

graph_.toggle_updating();
graph_.add_node(Node( ...
    'label', 'frame_1', ...
    'pipeline', @data.read_image, ...
    'group', 1, ...
    'outputnodes', 'merge'));
graph_.add_node(Node( ...
    'label', 'frame_2', ...
    'pipeline', @data.read_image, ...
    'group', 2));
graph_.add_node(Node( ...
    'label', 'transformation_matrix', ...
    'pipeline', ...
    @(~)data.load_parameter( ...
    [get_basis_path '..\data\other\transformation_matrix.mat']), ...
    'group', 2));
graph_.add_node(show_node.deep_copy());
graph_.add_node(Node( ...
    'label', 'register', ...
    'pipeline', ...
    @(image, ...
    transformation_matrix)preprocessing.transform_image ...
    (image, transformation_matrix), ...
    'inputnodes', {'frame_2', 'transformation_matrix'}, ...
    'outputnodes', 'show'));

% now that auto-updating is turned off, we need to call .initialize()
% manually. it is this method that is being called at every update.
graph_.initialize();

% notice that graph construction was slightly faster this time. the speedup
% is more noticable when constructing large graphs.
disp('graph created.');
toc;

graph_.plot();
graph_.print_summary();

%% run the graph just to make sure that it works
driver_ = Driver(Case( ...
    [get_basis_path '..\data\images\pyrometry\stepping']), ...
    graph_);
driver_.run();